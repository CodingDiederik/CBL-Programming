Create classes:
- main class: Game -> only one instance
- player class -> one instance
- class level -> later: make it a superclass of classes level1, level2, etc.
    - in constructor fill the level with the desired obstacles.
- Obstacles class: superclass of all obstacles we want to implement.

In case of moving enemy's: enemy class 

KeyEvent detection:
A Listener class is created and makes calls when certain keys are pressed.

Rendering the level:
frame.add(level): in level we override the paintComponent method to draw the level.
To be able to draw the player give the created player instance made in te Game class as parameter when creating the level.
We use the coordinatesystem of Swing to determine all positions: top-left corner of the screen is 0,0 all axis are increasing.
We use a timer that refreshes the screen every 120 frames per second.

PlayerMovement:
Use a physicsmodel with accelaration, gravity etc.
Determine te position of the player from it's center.

Jump
Sides:
- special graph for accelaration
- max speed
- 

COLLISIONDETECTION:

This is how it has to work:

If a sidekey is pressed: 
- check which side
- how much do you move? (speed)
- Check if you collide
- if collide --> move as far as you can go
- if you dont collide --> move

If upkey is pressed:
- check if on ground
- start jump
- You have to be able to execute other functions during jump
- if you collide with something: stop jump
    if you start falling: (vertical speed == 0)
     Start falling

If you walk of platform
- start falling
- during fall: be able to execute other functions

on ground check has to be checked all the time

How to implement:
Left and right movement:
- Method: calcChangeX: Calculate how far you going to move
  - 

When you move while you jump or fall (/the jump or fall fuction is being executed),
you dont have to account for the y-direction when checking for collisions in the x-direction, and vice-verca.
This is because we implement the functionality of moving as far as you can go if a collision is detected on the intended trajectory.
  -> if it would happen that you can overshoot the collision because of your increasing/decreasing your y-position, 
  the game would recieve a new keyEvent, check for collisions again and not detect a collision anymore.
